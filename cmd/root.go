/*
Copyright Â© 2022 Juan Antonio Osorio

*/
package cmd

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/cenkalti/backoff/v4"
	git "github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	githttp "github.com/go-git/go-git/v5/plumbing/transport/http"
	"github.com/google/go-github/v45/github"
	"github.com/spf13/cobra"
	"golang.org/x/oauth2"
	"gopkg.in/yaml.v3"
)

const (
	withWorktree   = false
	generalTimeout = 120 * time.Second
	resultPerPage  = 50
)

var l = log.Default()

// rootCmd represents the base command when called without any subcommands.
var rootCmd = &cobra.Command{
	Use:   "autopr",
	Short: "A brief description of your application",
	Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	Run: autoPRMain,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	ctx, cancel := context.WithTimeout(context.Background(), generalTimeout)
	defer cancel()

	err := rootCmd.ExecuteContext(ctx)
	if err != nil {
		os.Exit(1)
	}
}

// nolint // This is auto-generated by cobra.
func init() {
	rootCmd.Flags().StringP("org", "o", "", "GitHub Organization")
	rootCmd.Flags().StringP("processor", "p", "", "Processor script to use")
	rootCmd.Flags().StringP("repo", "r", "", "GitHub Repository (optional)")
}

type repoRef struct {
	URL    string
	Branch string
}

func getCreds() (user, token string) {
	if os.Getenv("GITHUB_TOKEN") != "" {
		token = os.Getenv("GITHUB_TOKEN")
		l.Println("Using token from environment variable 'GITHUB_TOKEN'")
		return
	}
	dirname, err := os.UserHomeDir()
	if err != nil {
		log.Fatal(err)
	}

	path := filepath.Join(dirname, ".config/gh/hosts.yml")
	f, err := os.Open(path)
	if err != nil {
		if os.IsNotExist(err) {
			l.Printf("No '%s' not using a token.\n", path)
			return "", ""
		}
		panic(err)
	}
	var hosts map[string]any
	d := yaml.NewDecoder(f)
	if derr := d.Decode(&hosts); derr != nil {
		panic(derr)
	}

	ghConfigRaw := hosts["github.com"]
	ghConfig, ok := ghConfigRaw.(map[string]interface{})
	if !ok {
		panic("github.com not found in hosts.yml")
	}

	l.Printf("Using token from '~/.config/gh/hosts.yml'\n")
	user, ok = ghConfig["user"].(string)
	if !ok {
		panic("user not found or of invalid type in hosts.yml")
	}
	token, ok = ghConfig["oauth_token"].(string)
	if !ok {
		panic("user not found or of invalid type in hosts.yml")
	}
	return user, token
}

func getHTTPClient(ctx context.Context, token string) *http.Client {
	if token != "" {
		ts := oauth2.StaticTokenSource(
			&oauth2.Token{AccessToken: token},
		)
		tc := oauth2.NewClient(ctx, ts)
		return tc
	}

	return nil
}

type iteratorFunc func() []repoRef

func getRepoRef(r *github.Repository) repoRef {
	return repoRef{
		URL:    r.GetSVNURL(),
		Branch: r.GetDefaultBranch(),
	}
}

func getIterator(ctx context.Context, ghc *github.Client, org, repo string) iteratorFunc {
	if repo != "" {
		return func() []repoRef {
			repo, _, err := ghc.Repositories.Get(ctx, org, repo)
			if err != nil {
				panic(err)
			}
			return []repoRef{getRepoRef(repo)}
		}
	}

	return func() []repoRef {
		opt := &github.RepositoryListByOrgOptions{
			Type: "all",
			ListOptions: github.ListOptions{
				PerPage: resultPerPage,
			},
		}
		var result []repoRef
		for {
			repos, resp, err := ghc.Repositories.ListByOrg(ctx, org, opt)
			if err != nil {
				// nolint // NOTE(jaosorior): This was recommended in the
				// go-github docs. I'm too lazy to try something else
				if _, ok := err.(*github.RateLimitError); ok {
					log.Println("hit rate limit")
					time.Sleep(10 * time.Second)
					// try again after some seconds
					repos, resp, err = ghc.Repositories.ListByOrg(ctx, org, opt)
					if err != nil {
						panic(err)
					}
				} else {
					panic(err)
				}
			}
			for _, repo := range repos {
				if repo.Archived != nil && *repo.Archived {
					continue
				}
				result = append(result, getRepoRef(repo))
			}
			if resp.NextPage == 0 {
				break
			}
			opt.Page = resp.NextPage
		}
		return result
	}
}

func cloneRepo(repoRef repoRef, user, token string) (string, error) {
	targetDir, terr := ioutil.TempDir("", "bark-git-")
	if terr != nil {
		return "", fmt.Errorf("failed to create temp dir: %w", terr)
	}

	opts := &git.CloneOptions{
		URL:           repoRef.URL,
		ReferenceName: plumbing.NewBranchReferenceName(repoRef.Branch),
	}

	if token != "" {
		if user == "" {
			user = "auto-pr"
		}

		opts.Auth = &githttp.BasicAuth{
			// the Username can be anything but it can't be empty
			Username: user,
			Password: token,
		}
	}

	err := backoff.RetryNotify(func() error {
		ctx, cancel := context.WithTimeout(context.Background(), generalTimeout)
		defer cancel()
		_, err := git.PlainCloneContext(ctx, targetDir, withWorktree, opts)
		if err != nil {
			if strings.Contains(err.Error(), "remote repository is empty") {
				return backoff.Permanent(err)
			}
		}
		return err
	}, backoff.NewExponentialBackOff(), func(err error, d time.Duration) {
		l.Printf("Failed to clone repo: %s. Retrying\n", err)
	})
	if err != nil {
		return targetDir, fmt.Errorf("could not clone repo: %w", err)
	}
	return targetDir, nil
}

func cleanup(dir string) {
	if err := os.RemoveAll(dir); err != nil {
		l.Printf("failed to remove temp dir: %s\n", err)
	}
}

func getScriptPath(script string) string {
	absscriptpath, abserr := filepath.Abs(script)
	if abserr != nil {
		l.Printf("failed to get absolute path for %s: %s\n", script, abserr)
		return ""
	}

	return absscriptpath
}

func processRepository(
	ctx context.Context,
	ghc *github.Client,
	user string,
	token string,
	repoRef repoRef,
	script string,
	inr io.Reader,
	outw, errw io.Writer,
) error {
	l.Printf("* Processing repository '%s@%s'\n", repoRef.URL, repoRef.Branch)
	targetDir, err := cloneRepo(repoRef, user, token)
	if targetDir != "" {
		defer cleanup(targetDir)
	}
	if err != nil {
		return err
	}

	cmd := exec.Command(script)
	cmd.Dir = targetDir
	cmd.Stdin = inr
	cmd.Stdout = outw
	cmd.Stderr = errw
	if cmdErr := cmd.Run(); cmdErr != nil {
		return fmt.Errorf("failed to run processor script: %w", cmdErr)
	}

	return nil
}

func autoPR(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()
	org, err := cmd.Flags().GetString("org")
	if err != nil || org == "" {
		return fmt.Errorf("'org' flag is required")
	}
	script, err := cmd.Flags().GetString("processor")
	if err != nil || script == "" {
		return fmt.Errorf("'processor' flag is required")
	}

	// nolint // it's not a big issue if we can't retrieve
	// a repo from the command line arguments.
	repo, _ := cmd.Flags().GetString("repo")

	spath := getScriptPath(script)

	user, token := getCreds()
	ghc := github.NewClient(getHTTPClient(ctx, token))

	it := getIterator(ctx, ghc, org, repo)

	var lastErr error
	for _, repo := range it() {
		err := processRepository(ctx, ghc, user, token, repo, spath, cmd.InOrStdin(), cmd.OutOrStdout(), cmd.OutOrStderr())
		if err != nil {
			lastErr = err
			l.Printf("Failed to process repository '%s@%s': %s\n", repo.URL, repo.Branch, err)
		}
	}
	return lastErr
}

func autoPRMain(cmd *cobra.Command, args []string) {
	if err := autoPR(cmd, args); err != nil {
		l.Printf("Error: %s\n", err)
		os.Exit(1)
	}
}
